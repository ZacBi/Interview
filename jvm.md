# JVM

## 类加载过程

### 类加载

加载 -> 链接 -> 初始化

其中链接阶段又分为验证, 准备, 解析三阶段.

#### 加载

1. 通过全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象, 作为方法区这个类的各种数据的访问口

#### 链接

1. 验证: 验证class文件是否符合规范
2. 准备:
    - 为**类变量**分配内存并且设置该变量的初始默认值, 即零值
    - 这里不包含用final修饰的static, 因为final在编译时就会分配, 准备阶段会显式的初始化;
    - 不会为实例变量初始化, 类变量的赋值在初始化中, 而实例变量是会随着对象一起分配到Java堆中
3. 解析:
    - 符号引用转换为直接引用

#### 初始化

- 初始化阶段就是执行构造方法\<clinit>()过程
- 方法不需要定义, 是javac编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来
- 构造器方法中指令按语句在源文件中出现的顺序执行
- \<clinit>()不同于类的构造器
- 若父类具有\<clinit>()需要父类先完成初始化, 再初始化到子类
- 虚拟机必须保证一个类的\<clinit>()方法在多线程下被同步加锁

## 类加载器

JVM记载其: 引导类加载器

### 启动类加载器(引导类加载器, Bootstrap ClassLoader)

- 用来加载Java的核心库(JAVA_HOME/jre/lib/rt.jar, resources.jar或sun.boot.class.path路径下的内容),用于提供JVM自身需要的类
- 并不继承自java.lang.ClassLoader, 没有父加载器
- 加载扩展类和应用程序类加载器, 并指定为他们的父类加载器
- 出于安全考虑, Bootstrap类加载器值加载包名为java, javax, sun等开头的类

### 双亲委派机制

优点:

- 避免类的重复加载, 定义了类的加载顺序
- 保护程序安全, 防止核心API被随意篡改
  - 自定义类: java.lang.String, 直接加载java包下的String类而不是自定义类, 防止篡改
  - 自定义类: java.lang.ZacBiTest, 访问核心类库需要权限, 当加载这个类时, 会报错
- 沙箱保护机制

### 类加载子系统

- JVM中表示两个class对象是否为同一个类存在两个必要条件:
  - 类的完整类名必须一样, 包括包名
  - 加载这个类的ClassLoader也必须是相同的

JVM必须知道一个类型是由启动加载器加载还是由用户类加载器加载的.
如果一个类型是由用户类加载器加载的, 那么JVM会将这个类加载器的一个引用作为类型信息的一部分保存在方法区中.
当解析一个类型到另一个类型的引用时, JVM需要保证这两个类型的类加载器是相同的.

## 运行时数据区概述及线程

### 概述

运行时数据区包括:

- 本地方法栈
- 程序计数器
- 虚拟机栈
  - 其中栈帧包括: 局部变量表, 操作栈, 动态链接, 方法返回地址
- 堆区: Eden, s0, s1, old
- 元数据区(jdk8之前名为方法区, 又称为持久代, permanent generation): 常量池, 方法元信息, 类元信息
- 代码缓存

虚拟机的不同实现的区别主要在方法区.

对于运行时数据区, 有些部分是和进程(虚拟机实例)生命周期一样, 有些部分则和线程的生命周期一样.

- 每个线程独立: 包括程序计数器, 虚拟机栈, 本方法地栈
- 线程间共享: 堆, 堆外内存(永久代或元空间, 代码缓存)

重点优化在堆区(95%), 还有部分在方法区(5%), jdk8以后方法区又改称为元空间

### 线程

在hotspot JVM里, 每个线程都与操作系统的本地线程直接映射.

- 当一个Java线程创建时, 在操作系统本地也会建立一个相对应的线程. 当Java线程结束以后, 本地线程也会回收.

### 程序计数器

JVM中的程序计数器全称应该是程序技术寄存器(Program Counter Register),
它是对CPU的PC寄存器的抽象

GC: 垃圾回收只发生在**方法区**和**堆区**
OOM: 只有PC寄存器没有栈溢出, 运行时数据区的其他仍和部分都有可能发生OutOfMemoryError

三个问题:

- 使用PC寄存器存储字节码指令地址有什么用?
  - 因为CPU需要不停的切换哥哥线程, 当切换回来以后, 就得知道接着从哪开始继续执行
- 为什么使用PC寄存器记录当前线程的执行地址?
  - JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令
- PC寄存器为什么会被设定为**线程私有**?
  - 为了能够准确地记录各个线程正在执行的当前字节码指令地址, 最好的办法自然是为每一个线程都分配一个PC寄存器

### 虚拟机栈

其中栈帧包括: 局部变量表, 操作栈, 动态链接, 方法返回地址  
栈是运行时的数据结构, 而堆是存储的数据结构
即: 栈解决程序的运行问题, 即程序如何执行, 或者说如何处理数据. 堆解决的是数据存储的问题, 即数据怎么放, 放在哪儿.

每个线程在创建时都会创建一个虚拟机栈, 其内部保存一个个栈帧, 对应这一次次的Java方法调用
其生命周期和创建它的线程一致, 主要的作用是管理Java程序的运行,
它保存方法的局部变量(8种基本数据类型, 对象的引用地址)和部分结果, 并参与方法的调用和返回

- 局部变量 vs 成员变量
- 基本数据变量 vs 引用类型变量(类, 数组, 接口)

栈的优点:

- 快速有效的分配存储方式, 访问速度仅次于程序计数器
- JVM直接对Java栈的操作只有两个
  - 每个方法的执行, 伴随着入栈
  - 执行结束之后出栈
- 对于栈来说不存在垃圾回收的(因为方法结束以后栈自然就空了, 更准确地来说应该是线程以后, 虚拟机栈就直接清空了)

**面试题**
开发中有哪些异常

栈可能出现的异常

- Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的
  - 如果擦用固定大小的Java虚拟机栈, 那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定. 如果线程请求分配的栈的容量大于虚拟机栈允许的最大容量, Java虚拟机将会抛出一个StackOverflowError异常
  - 如果Java虚拟机栈可以动态扩展, 并且在尝试扩展的时候无法申请到足够的内存, 或者创建新的线程时没有足够的内存去创建对应的虚拟机栈, 那Java虚拟机将会抛出一个OutOfMemoryError

#### 局部变量表

##### Slot

回忆8种基本数据类型: byte, short, int, long, float, double, char, boolean.
其中double, long是占两个slot(32位), 此外, object reference也占两个slot.

**关于为什么不能在静态方法中使用this的原因**
从栈帧的角度来说, 若当前帧是由构造方法或者实例方法创建的, 那么该对象引用this将会存放在**局部变量表**index为0的slot处, 反之, 若是由静态方法创建, 则不会存在this对象的引用, 那么自然报错了.

##### 静态变量和局部变量的对比

变量的分类:

- 按照数据类型分类: 基本数据类型, 引用数据类型
- 按照在类中的声明位置分类:
  - 成员变量: 这类变量的一般在使用前都经历过默认初始化赋值
    - 类变量: linking的prepare阶段, 给类变量默认复制, 在 initialization时进行显式赋值, 即静态代码块赋值.
    - 实例变量: 随着对象的创建, 会在堆空间中分配实例变量空间, 并进行默认赋值.
  - 局部变量: 在使用前必须要进行显式赋值, 否则编译不会通过.

**局部变量表中的变量也是重要的垃圾回收根结点, 只要被局部变量中直接或间接引用的对象都不会被回收**: 可达性分析

#### 操作数栈(operand stack)

操作数栈, 主要用于保存计算过程的中间结果, 同时作为计算过程中变量临时的存储空间.  
操作数栈就是JVM执行引擎的一个工作区, 当一个方法刚开始执行的时候, 一个新的栈帧也会随之被创建出来, 这个方法的操作数栈是空的.  
每一个操作数栈都会有一个明确的栈深度用于存储数值, 其所需的最大深度在编译器就定义好了, 保存在方法的Code属性中, 为max_stack的值.  
栈中任意一个元素都可以是仍以的Java数据类型.(32位占一个slot, 64位占两个slot)
**如果被调用的方法带有返回值的话, 其返回值将会被压入当前栈帧的操作栈中, 并更新PC寄存器中下一条需要执行的字节码指令**

由于操作数是存储在内存中的, 因此频繁地执行IO操作必然会影响执行速度. 为了解决这个问题, HotSPot JVM的设计者提出了**栈顶缓存**(ToS, Top-of-Stack Cashing)技术, 将栈顶元素全部缓存在屋里CPU的寄存器中, 以此降低对内存的读/写次数, 提升执行引擎的执行效率.  

#### 动态链接

在Java源文件被编译到字节码文件中时, 所有的变量和方法引用都作为**符号引用**保存在class文件的常量池里, 比如: 描述一个方法调用了另外的其他方法时, 就是通过常量池中指向方法的符号引用来表示的, 那么动态连接的作用就是为了将这些符号引用转换为调用方法的直接引用.(**注意区分class文件常量池和运行时常量池**).

问题: 为什么需要运行时常量池?  
主要是为了节省内存, 我们知道动态链接是每个方法的栈帧里面指向运行时常量池数据的引用, 比如说现在要修改某个类变量, 我们直接用引用指向该类变量更方便, 如果不存在运行时常量池, 结果就是每个栈帧都要存放一些冗余的数据, 这就导致内存的浪费.

#### 方法的调用

静态链接和动态链接对应的方法的绑定机制为: 早期绑定和晚期绑定. **绑定是一个字段, 方法或者类在符号引用被替换为直接引用的过程, 这仅仅发生一次**

Java中仍和一个普通的方法其实都具备虚函数的特征, 即运行时才能将符号引用转为直接引用的特性. 如果在Java程序中不希望某个方法拥有虚函数的特征时, 则可以使用关键字final来标记这个方法.

##### 虚方法与非虚方法

非虚方法:

- 如果方法在编译器就确定了具体的调用版本, 这个版本在运行时是不可变的. 这样的方法称为非虚方法
- 静态方法, 私有方法, final方法, 实例构造器, 父类方法都是非虚方法
- 其他方法称为虚方法

很明显, 非虚方法和多态的实现是严重冲突的.

方法调用的四种普通指令

- invokespecial
- invokestatic
- invokevirtual
- invokeinterface

动态调用指令

- invokedynamic: jdk8中加入, 主要是为了支持`Lambda`表达式而实现函数式编程

Java是静态类型语言, 静态类型与动态类型的区别在于类型的检查是在编译期执行还是运行期执行. 更直白一点, 动态型语言是判断变量值的类型信息, 变量没有类型信息, 变量值才有类型信息, 而静态类型语言是判断变量自身的类型信息.

##### 方法重写的本质

1. 找到操作数栈顶的第一个元素所执行的对象的实际类型, 记作C
2. 如果在

## Java并发

### Java内存模型

Java内存模型和前面的JVM分布有所不同, JMM(Java Memory Model)是用来屏蔽各种硬件和操作系统的**内存访问**差异, 以实现让Java程序在个平台下都能达到一致的内存访问效果.

在<<深入理解JVM>>中对于JMM的描述是这样的
> Java内存模型的主要目的是定义程序中各种变量的访问规则, 即关注虚拟机中把变量值存储到内存和从内存民众取出变量值这样的底层细节.

这里描述的变量指的是实例字段, 静态字段和构成数组对象的元素, 但是不包括局部变量和方法参数, 因为后者是线程私有的, 不会被共享, 自然不会存在竞争问题.

JVM虚拟机将内存分为两块, 一个是主内存, 一个是工作内存, 可以类比为硬件中的内存和cache. 工作内存是线程私有的, 对于变量来说(JMM中的变量), 每次都需要通过原子指令(lock, unlock, read, load, use, assign, store, write)进行工作内存和主内存之间的交互.

### Volatile关键字

Volatile是JVM提供的最轻量级的同步机制. 它具有两个特点: 保证此变量对于线程的可见性; 屏蔽指令重排序优化.

对于第一点, 是通过read, load和use, assign, store和write之间的绑定来执行的, 保证使用变量或者对变量的赋值能够最快的在主内存中更新, 使得其他线程可以立即得知的. 但是**volatile并不保证线程安全的**. 因为对于volatile字段修饰的变量来讲, 以自加操作举例, 自加操作的代码可能翻译成字节码后(更进一步, 机器码), 表现为多个原子操作. 如果线程被切换(阻塞, 等待等等), 那么有可能出现幻写的情况.

对于第二点, 指令重排序优化可以不详细考虑.

### 线程

如上
