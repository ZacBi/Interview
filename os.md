# OS

## 2. 进程

### 2.1

#### 2.1.3 进程控制

进程控制负责对系统中所有的进程进行管理, 包括进程创建, 进程撤销和进程的状态转换.

1. 创建进程: 初始化PCB, 分配系统资源.
2. 就绪态->运行态: 需要恢复进程运行环境, 修改PCB相应内容和相应队列.

用原语实现进程控制. 原语的特点是执行期间不允许中断, 只能一气呵成.
这种不可被中断的操作即原子操作. 原语采用"关中断指令"和"开中断指令"实现.

1. 关中断: 为了防止被中断, 我们需要关闭中断
2. 执行原语代码
3. 开中断指令, 原语结束完成, 重新打开中断.

关中断/开中断的权限非常大, 必然只能在核心态下执行的特权指令.

原语一般需要做的事情:
1. 更新PCB中的信息(如修改进程的状态标志, 将运行环境保存到PCB, 从PCB中恢复状态信息
   1. 所有的进程控制原语一定会修改进程状态标志
   2. 剥夺当前运行进程的CPU使用权必然需要保存运行环境
   3. 某进程开始运行前必然要恢复运行环境
2. 将PCB插入合适的队列
3. 分配/回收资源

#### 2.1.4 进程通信

进程是分配系统资源的基本单位, 每个进程都有独立的地址空间. 为了保证进程的安全性, 一个进程不能访问另一个进程的地址空间.
但是进程之间的信息交换又是必须实现的, 为了保证进程间的安全通信, 操作系统提供了一些方法.

#### 共享存储

通过共享的内存空间进行通信, 需要注意的是, 进程对于共享空间的访问是互斥的.

共享存储的分类:
1. 基于数据结构的共享
2. 基于存储区的共享

#### 管道通信

管道是指用于连接读写进程的一个共享文件, 又名pipe文件. 其实就是在内存中开辟一个的大小固定的缓冲区.

1. 管道只能实现半双工通信, 如果要双向同时通信, 需要设置两个管道.
2. 数据以字符流的形式写入管道, 当管道写满以后, 写进程的write()将被阻塞, 等待读进程将数据取走, 当读进程将数据取走以后, 管道变空, 此时读进程的read()系统调用将被阻塞.

#### 消息传递

#### 2.1.5 线程

引入线程以后, 线程成为程序执行流的最小单位.
线程可以理解为"轻量级的进程"

1. 线程是处理机调度的基本单位
2. 多CPU中, 不同线程可以占用不同cpu
3. 每一个线程都有一个线程ID, 线程控制块(TCB)
4. 线程有就绪, 运行, 阻塞三种状态
5. 线程几乎不拥有系统资源
6. 同一进程的不同线程间共享进程资源
7. 由于共享进程资源, 统一进程的线程之间通信不需要系统干预
8. 同一进程的线程切换, 不会引起进程切换
9. 不同进程的线程切换, 会引起进程切换
10. 切换同进程间的线程, 系统开销很小
11. 切换进程, 系统开销比较大

内核级的线程由操作系统内核完成, 线程调度, 切换等工作都由内核负责, 因此
内核级的线程切换必然是内核态才能完成, 

### 2.3

#### 2.3.1 进程同步与互斥

进程同步是为了解决进程并发执行可能产生的一系列问题.
以管道为例, 读写进程都可以对管道进行操作, 但是读的操作一定是在写操作之后的, 如何解决这种异步问题, 就是进程同步所讨论的内容.

系统中有一些资源, 只能互斥的进行访问, 比如打印机, 摄像头之类的, 我们称之为**临界资源**, 对临界资源的访问可以分为4步:

```c
do {
   entry section;    //进入区, 负责检查是否能进入临界区, 等于"上锁"
   critical section; // 临界区, 访问临界资源
   exit section;     //退出区, 解除对临界资源的访问, 等于"解锁"
   remaminer section; //剩余区, 其他处理
}
```

**需要遵循的原则**
1. 空闲让进
2. 忙则等待
3. 有限等待: 对请求访问的进程, 应保证有限时间内进入临界区.
4. 让权等待: 当进程不能进入临界区, 应能立即释放处理机, 防止忙等待.


#### 2.3.4 信号量机制

信号量分为两种: 整型信号量, 记录型信号量.
整型信号量, 和普通变量相比只能有三种操作: 初始化, P操作(wait), V操作(signal). 整形信号量不满足让权等待原则, 会发生"忙等"
```java
int S = 1;
void wait(int S){
   while (S <= 0);
   S = S - 1;
}

void signal(int S){
   S = S + 1;
}
```

记录型信号量, 为了解决整形信号量忙等的问题.

```c++
typedef struct {
   int value;
   struct process *L;
} 

void wait (semaphore S){
   S.value--;
   if (S.value < 0) {
      /* 如果剩余资源数不够, 则使用block原语把进程从
      * 运行态进入阻塞态, 并把其挂载到信号量S的等待队列中 */
      block (S.L) 
   }
}
```

#### 2.3.5 信号量实现进程互斥, 同步, 前驱关系

1. 分析并发进程的关键活动, 划分临界区(如: 对临界资源打印机的访问就应该放在临界区)
2. 设置互斥信号量`mutex`, 初值为1.
3. 临界区之前执行P(mutex)
4. 临界区之后执行V(mutex)

```c
semaphore mutex=1;

P1(){
   P(mutex);
   // critical region
   V(mutex);
}

P2(){
   P(mutex);
   // critical region
   V(mutex);
}
```

**信号量实现进程同步**
1. 分析什么地方需要"同步关系", 必须保持"一前一后"执行的两个操作(或两句代码)
2. 设置同步量S, 初始化为0
3. 在"前操作"之后执行V(S)
4. 在"后操作"之前执行P(S)

```c
semaphore S = 0;

P1(){
   //code1
   //code2
   V(S);
   //code3
}

P2(){
   P(S);
   //code4
   //code5
   //code6
}

//注意:code4需要code2的结果
```

**信号量实现前驱关系**(每一对前驱关系都是一个进程同步问题)
1. 为每一对前驱关系各设置一个同步变量
2. 在"前操作"之后对应的同步变量执行V操作
3. 在"后操作"之前对应的同步变量执行P操作

#### 2.3.5 生产者消费者问题

缓冲区属于临界资源, 需要互斥的访问.
要点:
1. 实现互斥的P操作一定要在实现同步的P操作之后
2. V操作不会导致进程阻塞, 因此两个V操作顺序可以交换.

PV操作解题思路
1. 关系分析. 找出题目中描述的各个进程, 分析他们之间的同步, 互斥关系
2. 整理思路. 根据各进程的操作流程确定P, V操作的大致顺序
3. 设置信号量. 设置需要的信号量, 并根据题目条件确定初始信号量.

#### 2.3.6 多生产者-多消费者

#### 2.3.7 吸烟者问题

为解决"可以生产多个产品的单生产者"提供思路

#### 2.3.8 读者-写者问题

读者-写者问题为我们解决复杂的互斥问题提供了思路. 其核心思想在于, 设置一个计数器count用来访问共享文件的读进程数, 我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程, 从而做出不同的处理.
另外, 对count的不能一气呵成处理造成了一些错误, 如果需要一气呵成的完成某一操作, 应该想到使用互斥信号量.
最后需要解决"写进程饥饿"的问题.